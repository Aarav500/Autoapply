name: Deploy via SSM (No SSH Key Required)

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2 via AWS SSM
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --no-fund

      - name: Build Next.js application
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
        run: npm run build

      - name: Create deployment package
        run: |
          tar --exclude='.git' \
              --exclude='node_modules' \
              --exclude='src' \
              --exclude='*.md' \
              --exclude='.env*' \
              --warning=no-file-changed \
              -czf deploy.tar.gz \
              .next \
              public \
              Dockerfile.fast \
              package.json \
              next.config.ts || [[ $? -eq 1 ]]

          ls -lh deploy.tar.gz
          echo "Package size: $(du -h deploy.tar.gz | cut -f1)"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload to S3
        run: |
          aws s3 cp deploy.tar.gz s3://${{ secrets.S3_BUCKET_NAME }}/deployments/autoapply-${{ github.sha }}.tar.gz
          echo "‚úÖ Uploaded to S3"

      - name: Deploy via SSM
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          COMMIT_SHA: ${{ github.sha }}
          AWS_KEY: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION_VAL: ${{ secrets.AWS_REGION }}
          CLAUDE_KEY: ${{ secrets.CLAUDE_API_KEY }}
          APP_URL: ${{ secrets.NEXTAUTH_URL }}
          GOOGLE_CID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TWILIO_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_PHONE: ${{ secrets.TWILIO_PHONE_NUMBER }}
          TWILIO_MSG_SID: ${{ secrets.TWILIO_MESSAGING_SERVICE_SID }}
          SENDGRID_KEY: ${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_EMAIL: ${{ secrets.SENDGRID_FROM_EMAIL }}
        run: |
          echo "üöÄ Deploying to EC2..."

          INSTANCE_ID="${{ secrets.EC2_INSTANCE_ID }}"

          echo "üìç Instance: $INSTANCE_ID"
          echo "üìç Bucket: $S3_BUCKET"
          echo "üìç Commit: $COMMIT_SHA"

          # Send SSM command with inline array (like the working script)
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "AutoApply deployment - $COMMIT_SHA" \
            --timeout-seconds 1800 \
            --parameters "commands=[
              \"set -e\",
              \"echo '=== AutoApply Deployment Started ==='\",
              \"echo 'Commit: ${COMMIT_SHA}'\",
              \"echo 'Time: \$(date)'\",
              \"WORKDIR=/tmp/autoapply-deploy-${COMMIT_SHA}\",
              \"mkdir -p \$WORKDIR && cd \$WORKDIR\",
              \"echo '=== Downloading from S3 ==='\",
              \"aws s3 cp s3://${S3_BUCKET}/deployments/autoapply-${COMMIT_SHA}.tar.gz . || exit 1\",
              \"ls -lh autoapply-${COMMIT_SHA}.tar.gz\",
              \"echo '=== Extracting ==='\",
              \"tar -xzf autoapply-${COMMIT_SHA}.tar.gz || exit 1\",
              \"ls -la\",
              \"echo '=== Building Docker image ==='\",
              \"export DOCKER_BUILDKIT=1\",
              \"docker build -f Dockerfile.fast --progress=plain -t autoapply:latest . || exit 1\",
              \"echo '=== Stopping old container ==='\",
              \"docker stop autoapply 2>/dev/null || true\",
              \"docker rm autoapply 2>/dev/null || true\",
              \"echo '=== Starting new container ==='\",
              \"docker run -d --name autoapply --restart unless-stopped -p 80:3000 -e NODE_ENV=production -e AWS_ACCESS_KEY_ID='${AWS_KEY}' -e AWS_SECRET_ACCESS_KEY='${AWS_SECRET}' -e AWS_REGION='${AWS_REGION_VAL}' -e S3_BUCKET_NAME='${S3_BUCKET}' -e ANTHROPIC_API_KEY='${CLAUDE_KEY}' -e APP_URL='${APP_URL}' -e JWT_ACCESS_SECRET=\\\"\\\$(openssl rand -hex 32)\\\" -e JWT_REFRESH_SECRET=\\\"\\\$(openssl rand -hex 32)\\\" -e ENCRYPTION_KEY=\\\"\\\$(openssl rand -hex 32)\\\" -e GOOGLE_CLIENT_ID='${GOOGLE_CID}' -e GOOGLE_CLIENT_SECRET='${GOOGLE_SECRET}' -e GOOGLE_REDIRECT_URI='${APP_URL}/api/auth/oauth/google/callback' -e TWILIO_ACCOUNT_SID='${TWILIO_SID}' -e TWILIO_AUTH_TOKEN='${TWILIO_TOKEN}' -e TWILIO_PHONE_NUMBER='${TWILIO_PHONE}' -e TWILIO_MESSAGING_SERVICE_SID='${TWILIO_MSG_SID}' -e SENDGRID_API_KEY='${SENDGRID_KEY}' -e SENDGRID_FROM_EMAIL='${SENDGRID_EMAIL}' autoapply:latest || exit 1\",
              \"echo '=== Waiting for app ==='\",
              \"sleep 15\",
              \"echo '=== Health check ==='\",
              \"for i in {1..20}; do curl -sf http://localhost:3000/api/health >/dev/null 2>&1 && echo '‚úÖ Health check passed' && curl -s http://localhost:3000/api/health && break; echo \\\"Attempt \$i/20...\\\"; sleep 3; done\",
              \"echo '=== Container logs ==='\",
              \"docker logs autoapply --tail 30\",
              \"echo '=== Container status ==='\",
              \"docker ps | grep autoapply\",
              \"echo '=== Cleanup ==='\",
              \"docker image prune -f\",
              \"cd /tmp && rm -rf \$WORKDIR\",
              \"echo '=== Deployment Complete ==='\",
              \"echo 'Commit: ${COMMIT_SHA}'\",
              \"echo 'Time: \$(date)'\",
              \"echo '==========================='\",
              \"echo 'Done'\"]" \
            --query "Command.CommandId" \
            --output text)

          echo "üìã Command ID: $COMMAND_ID"
          echo "‚è≥ Waiting for deployment (10-15 minutes)..."

          # Wait for completion (like the working script)
          for i in {1..90}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "[$((i * 10))s] Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "‚úÖ Deployment succeeded!"
              echo ""
              echo "=== DEPLOYMENT OUTPUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "‚ùå Deployment failed with status: $STATUS"
              echo ""
              echo "=== ERROR OUTPUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardErrorContent" \
                --output text
              echo ""
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text
              exit 1
            fi

            sleep 10
          done

      - name: Get EC2 IP
        id: get-ip
        run: |
          INSTANCE_ID="${{ secrets.EC2_INSTANCE_ID }}"

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)

          echo "ec2_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "EC2 Public IP: $PUBLIC_IP"

      - name: External health check
        run: |
          echo "Testing external access..."
          sleep 10

          IP="${{ steps.get-ip.outputs.ec2_ip }}"

          for i in {1..10}; do
            echo "Health check attempt $i/10..."
            if curl -sf "http://$IP/api/health"; then
              echo ""
              echo "‚úÖ External health check passed!"
              exit 0
            fi
            sleep 5
          done

          echo "‚ö†Ô∏è External health check failed"
          echo "Check security group allows port 80"

      - name: Deployment summary
        if: success()
        run: |
          IP="${{ steps.get-ip.outputs.ec2_ip }}"

          echo ""
          echo "========================================"
          echo "üéâ DEPLOYMENT COMPLETE!"
          echo "========================================"
          echo "üåê URL: ${{ secrets.NEXTAUTH_URL }}"
          echo "üìä IP: http://$IP"
          echo "üîå Health: http://$IP/api/health"
          echo "üìù Commit: ${{ github.sha }}"
          echo "========================================"
