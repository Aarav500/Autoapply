name: Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual deployment'
        required: false
        default: 'Manual trigger'

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build Next.js application
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy

          # Copy EVERYTHING from standalone output (including dotfiles like .next/)
          cp -r .next/standalone/. deploy/

          # Standalone output excludes static files - add them
          if [ -d ".next/static" ]; then
            cp -r .next/static deploy/.next/static
          else
            echo "Warning: .next/static not found, creating empty directory"
            mkdir -p deploy/.next/static
          fi

          # Verify BUILD_ID exists (required for production server)
          if [ ! -f "deploy/.next/BUILD_ID" ]; then
            echo "ERROR: BUILD_ID not found in deploy/.next/"
            ls -la deploy/.next/ || echo "deploy/.next/ does not exist"
            exit 1
          fi

          # Copy public files (not included in standalone)
          if [ -d "public" ]; then
            cp -r public deploy/public
          else
            mkdir -p deploy/public
          fi

          # Copy Dockerfile
          cp Dockerfile.fast deploy/Dockerfile

          # Copy docker-compose.yml if it exists
          cp docker-compose.yml deploy/ || true

          # Create .env file with ALL required environment variables
          {
            echo "NODE_ENV=production"
            echo "AWS_REGION=${{ env.AWS_REGION }}"
            echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}"
            echo "S3_REGION=${{ env.AWS_REGION }}"
            echo "ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}"
            echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}"
            echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}"
            echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}"
            echo "TWILIO_WHATSAPP_NUMBER=${{ secrets.TWILIO_WHATSAPP_NUMBER }}"
            echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}"
            echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}"
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}"
            echo "JWT_ACCESS_SECRET=${{ secrets.JWT_SECRET }}"
            echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}"
            echo "ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}"
            echo "NEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}"
            echo "APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}"
          } > deploy/.env

          tar -czf deploy.tar.gz -C deploy .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          S3_PATH="s3://${{ secrets.S3_BUCKET_NAME }}/deployments/${TIMESTAMP}/deploy.tar.gz"
          aws s3 cp deploy.tar.gz "$S3_PATH"
          echo "S3_PATH=$S3_PATH" >> $GITHUB_ENV

      - name: Get EC2 IP address
        id: get-ip
        run: |
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0]')

          EC2_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress')
          STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')

          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"
          echo "Instance State: $STATE"

          # Verify instance is running
          if [ "$STATE" != "running" ]; then
            echo "âŒ ERROR: Instance is not running (state: $STATE)"
            echo "Start the instance and try again"
            exit 1
          fi

      - name: Upload deploy script to S3
        run: |
          aws s3 cp scripts/deploy-ec2.sh "s3://${{ secrets.S3_BUCKET_NAME }}/deployments/deploy-ec2.sh"

      - name: Deploy via AWS Systems Manager
        run: |
          echo "ðŸš€ Deploying via AWS Systems Manager..."

          # Send deployment command via SSM
          # Use --output-s3-bucket-name to avoid IPC timeout on long Docker builds
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "AutoApply deployment - ${{ github.sha }}" \
            --timeout-seconds 600 \
            --output-s3-bucket-name "${{ secrets.S3_BUCKET_NAME }}" \
            --output-s3-key-prefix "ssm-output" \
            --parameters commands="[
              \"export S3_DEPLOY_PATH='${{ env.S3_PATH }}'\",
              \"aws s3 cp 's3://${{ secrets.S3_BUCKET_NAME }}/deployments/deploy-ec2.sh' /tmp/deploy-ec2.sh\",
              \"chmod +x /tmp/deploy-ec2.sh\",
              \"bash /tmp/deploy-ec2.sh\"
            ]" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for deployment to complete..."

          # Wait for command to complete (check every 10s, max 10 minutes)
          ATTEMPT=1
          MAX_ATTEMPTS=60
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "[$((ATTEMPT * 10))s] Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "âœ… Deployment succeeded!"
              echo ""
              echo "=== DEPLOYMENT OUTPUT ==="
              # Output is in S3, fetch last part
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text 2>/dev/null || echo "(output stored in S3)"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "âŒ Deployment failed with status: $STATUS"
              echo ""
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text 2>/dev/null || echo "(output stored in S3)"
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text 2>/dev/null || echo "(output stored in S3)"
              exit 1
            fi

            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance**: ${{ secrets.EC2_INSTANCE_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "- **IP**: ${{ steps.get-ip.outputs.ec2_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Package**: ${{ env.S3_PATH }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **Application URL**: http://${{ steps.get-ip.outputs.ec2_ip }}:3000" >> $GITHUB_STEP_SUMMARY
          fi
