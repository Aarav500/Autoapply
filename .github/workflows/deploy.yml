name: Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual deployment'
        required: false
        default: 'Manual trigger'

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build Next.js application
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy

          # Copy EVERYTHING from standalone output
          # This includes: server.js, node_modules, .next/ (with server, BUILD_ID, manifests)
          cp -r .next/standalone/* deploy/

          # Standalone .next ONLY missing static folder - add it if it exists
          if [ -d ".next/static" ]; then
            cp -r .next/static deploy/.next/static
          else
            echo "Warning: .next/static not found, creating empty directory"
            mkdir -p deploy/.next/static
          fi

          # Copy public files (not included in standalone)
          if [ -d "public" ]; then
            cp -r public deploy/public
          else
            mkdir -p deploy/public
          fi

          # Copy Dockerfile
          cp Dockerfile.fast deploy/Dockerfile

          # Copy docker-compose.yml if it exists
          cp docker-compose.yml deploy/ || true

          # Create .env file with ALL required environment variables
          cat > deploy/.env << EOF
          # Node environment
          NODE_ENV=production

          # AWS S3 Configuration (production uses real S3, not MinIO)
          AWS_REGION=${{ env.AWS_REGION }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
          S3_REGION=${{ env.AWS_REGION }}

          # AWS credentials will be provided via EC2 IAM role (no keys needed)
          # If using IAM user instead, add AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets

          # AI Services
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}

          # Twilio (SMS/WhatsApp)
          TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}
          TWILIO_WHATSAPP_NUMBER=${{ secrets.TWILIO_WHATSAPP_NUMBER }}

          # Google OAuth (Gmail, Calendar)
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}

          # JWT Secrets
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_SECRET=${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}

          # Encryption
          ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}

          # Application URL
          NEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}
          APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}
          EOF

          tar -czf deploy.tar.gz -C deploy .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          S3_PATH="s3://${{ secrets.S3_BUCKET_NAME }}/deployments/${TIMESTAMP}/deploy.tar.gz"
          aws s3 cp deploy.tar.gz "$S3_PATH"
          echo "S3_PATH=$S3_PATH" >> $GITHUB_ENV

      - name: Get EC2 IP address
        id: get-ip
        run: |
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0]')

          EC2_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress')
          STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')

          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"
          echo "Instance State: $STATE"

          # Verify instance is running
          if [ "$STATE" != "running" ]; then
            echo "âŒ ERROR: Instance is not running (state: $STATE)"
            echo "Start the instance and try again"
            exit 1
          fi

      - name: Deploy via AWS Systems Manager
        run: |
          echo "ðŸš€ Deploying via AWS Systems Manager..."

          # Send deployment command via SSM (includes dependency installation)
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "AutoApply deployment - ${{ github.sha }}" \
            --timeout-seconds 1800 \
            --parameters commands="[
              \"set -e\",
              \"echo '=== AutoApply Deployment ==='\",
              \"echo ''\",
              \"echo 'Step 1: Checking dependencies...'\",
              \"if ! command -v aws &> /dev/null; then echo '  Installing AWS CLI...'; sudo apt-get update -qq && sudo apt-get install -y -qq unzip && curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip && unzip -q awscliv2.zip && sudo ./aws/install && rm -rf aws awscliv2.zip; else echo '  âœ… AWS CLI installed'; fi\",
              \"if ! command -v docker &> /dev/null; then echo '  Installing Docker...'; sudo apt-get update -qq && sudo apt-get install -y -qq ca-certificates curl gnupg && sudo install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg && sudo chmod a+r /etc/apt/keyrings/docker.gpg && echo \\\"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\\\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && sudo apt-get update -qq && sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin && sudo usermod -aG docker ubuntu && sudo systemctl enable docker && sudo systemctl start docker; else echo '  âœ… Docker installed'; fi\",
              \"echo ''\",
              \"echo 'Step 2: Stopping existing containers...'\",
              \"sudo docker stop autoapply-app 2>/dev/null || true\",
              \"sudo docker rm autoapply-app 2>/dev/null || true\",
              \"echo ''\",
              \"echo 'Step 3: Downloading deployment package...'\",
              \"mkdir -p /home/ubuntu/autoapply\",
              \"cd /home/ubuntu/autoapply\",
              \"aws s3 cp '${{ env.S3_PATH }}' deploy.tar.gz\",
              \"echo ''\",
              \"echo 'Step 4: Extracting package...'\",
              \"rm -rf app\",
              \"mkdir -p app\",
              \"tar -xzf deploy.tar.gz -C app\",
              \"cd app\",
              \"echo ''\",
              \"echo 'Step 5: Building Docker image (this may take 10-15 minutes)...'\",
              \"sudo docker build -f Dockerfile -t autoapply:latest .\",
              \"echo ''\",
              \"echo 'Step 6: Starting container...'\",
              \"sudo docker run -d --name autoapply-app --restart unless-stopped -p 3000:3000 --env-file .env autoapply:latest\",
              \"echo ''\",
              \"echo 'Step 7: Waiting for application to start...'\",
              \"for i in {1..30}; do if curl -f http://localhost:3000/api/health >/dev/null 2>&1; then echo 'âœ… Application is healthy'; sudo docker logs autoapply-app --tail 20; echo ''; echo '=== Deployment Complete ==='; exit 0; fi; echo \\\"  Attempt \$i/30: waiting...\\\"; sleep 2; done\",
              \"echo 'âŒ Application failed to start'\",
              \"sudo docker logs autoapply-app\",
              \"exit 1\"
            ]" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for deployment to complete..."

          # Wait for command to complete (max 30 minutes)
          for i in {1..120}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "[$((i * 5))s] Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "âœ… Deployment succeeded!"
              echo ""
              echo "=== DEPLOYMENT OUTPUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "âŒ Deployment failed with status: $STATUS"
              echo ""
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text || echo "(empty)"
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text || echo "(empty)"
              exit 1
            fi

            sleep 5
          done

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance**: ${{ secrets.EC2_INSTANCE_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "- **IP**: ${{ steps.get-ip.outputs.ec2_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Package**: ${{ env.S3_PATH }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **Application URL**: http://${{ steps.get-ip.outputs.ec2_ip }}:3000" >> $GITHUB_STEP_SUMMARY
          fi
