name: Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    name: Build and Deploy to AWS EC2
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get EC2 instance IP
        id: get-ip
        run: |
          EC2_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"

      - name: Create deployment package
        run: |
          # Create a clean deployment package (source code only)
          # Use --warning=no-file-changed to ignore file changes during archiving
          tar --exclude='.git' \
              --exclude='node_modules' \
              --exclude='.next' \
              --exclude='*.log' \
              --exclude='.env' \
              --warning=no-file-changed \
              -czf deploy.tar.gz . || [[ $? -eq 1 ]]

      - name: Upload to S3
        run: |
          aws s3 cp deploy.tar.gz s3://${{ secrets.S3_BUCKET_NAME }}/deployments/autoapply-${{ github.sha }}.tar.gz

      - name: Deploy to EC2 via SSM
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "set -ex",
              "echo \"=== Starting deployment ===\"",
              "cd /home/ec2-user",
              "mkdir -p autoapply",
              "cd autoapply",
              "echo \"=== Downloading deployment package ===\"",
              "aws s3 cp s3://${{ secrets.S3_BUCKET_NAME }}/deployments/autoapply-${{ github.sha }}.tar.gz . || exit 1",
              "echo \"=== Extracting ===\"",
              "tar -xzf autoapply-${{ github.sha }}.tar.gz || exit 1",
              "echo \"=== Building Docker image ===\"",
              "docker build -t autoapply:${{ github.sha }} -t autoapply:latest . || exit 1",
              "echo \"=== Docker build successful ===\"",
              "docker images | grep autoapply",
              "echo \"=== Stopping old container ===\"",
              "docker stop autoapply 2>/dev/null || true",
              "docker rm autoapply 2>/dev/null || true",
              "echo \"=== Starting new container ===\"",
              "docker run -d --name autoapply --restart unless-stopped -p 80:3000 \
                -e NODE_ENV=production \
                -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
                -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
                -e AWS_REGION=${{ secrets.AWS_REGION }} \
                -e S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }} \
                -e ANTHROPIC_API_KEY=${{ secrets.CLAUDE_API_KEY }} \
                -e APP_URL=${{ secrets.NEXTAUTH_URL }} \
                -e JWT_ACCESS_SECRET=$(openssl rand -hex 32) \
                -e JWT_REFRESH_SECRET=$(openssl rand -hex 32) \
                -e ENCRYPTION_KEY=$(openssl rand -hex 32) \
                -e GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }} \
                -e GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }} \
                -e GOOGLE_REDIRECT_URI=${{ secrets.NEXTAUTH_URL }}/api/auth/oauth/google/callback \
                -e TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }} \
                -e TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }} \
                -e TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }} \
                -e TWILIO_MESSAGING_SERVICE_SID=${{ secrets.TWILIO_MESSAGING_SERVICE_SID }} \
                -e SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }} \
                -e SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_FROM_EMAIL }} \
                autoapply:latest || exit 1",
              "echo \"=== Container started ===\"",
              "docker ps | grep autoapply",
              "echo \"=== Waiting for app to start ===\"",
              "sleep 10",
              "echo \"=== Checking container logs ===\"",
              "docker logs autoapply --tail 50",
              "echo \"=== Testing health endpoint locally ===\"",
              "curl -f http://localhost:3000/api/health || echo Health check failed locally",
              "echo \"=== Cleaning up ===\"",
              "docker image prune -f",
              "rm autoapply-${{ github.sha }}.tar.gz",
              "echo \"=== Deployment complete ===\""
            ]' \
            --output text \
            --query 'Command.CommandId')

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for command to complete (may take 5-10 minutes for Docker build)..."

          # Poll for command completion (max 15 minutes)
          MAX_WAIT=900
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            echo "Status at ${ELAPSED}s: $STATUS"

            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Command finished with status: $STATUS"
              break
            fi

            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done

          # Get command output and error
          echo ""
          echo "=== STDOUT ==="
          aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'StandardOutputContent' \
            --output text || echo "Could not retrieve STDOUT"

          echo ""
          echo "=== STDERR ==="
          aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'StandardErrorContent' \
            --output text || echo "Could not retrieve STDERR"

          echo ""
          echo "=== FINAL STATUS ==="
          FINAL_STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Status' \
            --output text)
          echo "Final Status: $FINAL_STATUS"

          # Exit with error if deployment failed
          if [ "$FINAL_STATUS" != "Success" ]; then
            echo "‚ùå Deployment failed with status: $FINAL_STATUS"
            exit 1
          fi

      - name: Health check
        if: success()
        run: |
          echo "Waiting for application to start..."
          sleep 30

          MAX_ATTEMPTS=15
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS..."
            if curl -f http://${{ steps.get-ip.outputs.ec2_ip }}/api/health 2>/dev/null; then
              echo "‚úÖ Health check passed!"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep 10
          done

          echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
          echo "Fetching container logs..."
          aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker logs autoapply --tail 100"]' \
            --output text
          exit 1

      - name: Deployment summary
        if: success()
        run: |
          echo "üéâ Deployment successful!"
          echo "URL: ${{ secrets.NEXTAUTH_URL }}"
          echo "Health: http://${{ steps.get-ip.outputs.ec2_ip }}/api/health"
          echo "Commit: ${{ github.sha }}"
