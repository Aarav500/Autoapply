name: Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual deployment'
        required: false
        default: 'Manual trigger'

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build Next.js application
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy

          # Copy standalone output
          cp -r .next/standalone/* deploy/

          # Copy static files (create .next directory structure first)
          mkdir -p deploy/.next
          cp -r .next/static deploy/.next/static

          # Copy public files
          cp -r public deploy/public

          # Copy Dockerfile
          cp Dockerfile.fast deploy/Dockerfile

          # Copy docker-compose.yml if it exists
          cp docker-compose.yml deploy/ || true

          # Create .env file
          cat > deploy/.env << EOF
          NODE_ENV=production
          AWS_REGION=${{ env.AWS_REGION }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}
          TWILIO_WHATSAPP_NUMBER=${{ secrets.TWILIO_WHATSAPP_NUMBER }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
          NEXT_PUBLIC_APP_URL=${{ secrets.NEXT_PUBLIC_APP_URL }}
          EOF

          tar -czf deploy.tar.gz -C deploy .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          S3_PATH="s3://${{ secrets.S3_BUCKET_NAME }}/deployments/${TIMESTAMP}/deploy.tar.gz"
          aws s3 cp deploy.tar.gz "$S3_PATH"
          echo "S3_PATH=$S3_PATH" >> $GITHUB_ENV

      - name: Get EC2 IP address
        id: get-ip
        run: |
          # Get instance details
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0]')

          EC2_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress')
          STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')

          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"
          echo "Instance State: $STATE"

          # Verify instance is running
          if [ "$STATE" != "running" ]; then
            echo "âŒ ERROR: Instance is not running (state: $STATE)"
            echo "Start the instance and try again"
            exit 1
          fi

      - name: Deploy via AWS Systems Manager
        run: |
          echo "ðŸš€ Deploying via AWS Systems Manager..."

          # Send deployment command via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "AutoApply deployment - ${{ github.sha }}" \
            --timeout-seconds 1800 \
            --parameters commands="[
              \"set -e\",
              \"echo '=== Starting deployment ==='\",
              \"echo 'Stopping existing containers...'\",
              \"docker stop autoapply-app 2>/dev/null || true\",
              \"docker rm autoapply-app 2>/dev/null || true\",
              \"echo 'Downloading deployment package...'\",
              \"mkdir -p /home/ubuntu/autoapply\",
              \"cd /home/ubuntu/autoapply\",
              \"aws s3 cp '${{ env.S3_PATH }}' deploy.tar.gz\",
              \"echo 'Extracting package...'\",
              \"rm -rf app\",
              \"mkdir -p app\",
              \"tar -xzf deploy.tar.gz -C app\",
              \"cd app\",
              \"echo 'Building Docker image...'\",
              \"docker build -f Dockerfile -t autoapply:latest .\",
              \"echo 'Starting container...'\",
              \"docker run -d --name autoapply-app --restart unless-stopped -p 3000:3000 --env-file .env autoapply:latest\",
              \"echo 'Waiting for application to start...'\",
              \"for i in {1..30}; do if curl -f http://localhost:3000/api/health >/dev/null 2>&1; then echo 'âœ… Application is healthy'; docker logs autoapply-app --tail 20; exit 0; fi; echo \\\"Attempt \$i/30: waiting...\\\"; sleep 2; done\",
              \"echo 'âŒ Application failed to start'\",
              \"docker logs autoapply-app\",
              \"exit 1\"
            ]" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for deployment to complete..."

          # Wait for command to complete (max 30 minutes)
          for i in {1..120}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "[$((i * 5))s] Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "âœ… Deployment succeeded!"
              echo ""
              echo "=== DEPLOYMENT OUTPUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "âŒ Deployment failed with status: $STATUS"
              echo ""
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text || echo "(empty)"
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text || echo "(empty)"
              exit 1
            fi

            sleep 5
          done

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance**: ${{ secrets.EC2_INSTANCE_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "- **IP**: ${{ steps.get-ip.outputs.ec2_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Package**: ${{ env.S3_PATH }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **Application URL**: http://${{ steps.get-ip.outputs.ec2_ip }}:3000" >> $GITHUB_STEP_SUMMARY
          fi
