name: Deploy via SSH (Backup Method)

on:
  workflow_dispatch:
    inputs:
      skip_build:
        description: 'Skip Docker build (use existing image)'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    name: Deploy to EC2 via SSH
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get EC2 instance IP
        id: get-ip
        run: |
          EC2_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"

      - name: Create deployment package
        run: |
          tar --exclude='.git' \
              --exclude='node_modules' \
              --exclude='.next' \
              --exclude='*.log' \
              --exclude='.env' \
              --warning=no-file-changed \
              -czf deploy.tar.gz . || [[ $? -eq 1 ]]

      - name: Upload to S3
        run: |
          aws s3 cp deploy.tar.gz s3://${{ secrets.S3_BUCKET_NAME }}/deployments/autoapply-${{ github.sha }}.tar.gz

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          COMMIT_SHA: ${{ github.sha }}
          S3_BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          SKIP_BUILD: ${{ inputs.skip_build }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ANTHROPIC_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
          APP_URL: ${{ secrets.NEXTAUTH_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_PHONE_NUMBER: ${{ secrets.TWILIO_PHONE_NUMBER }}
          TWILIO_MESSAGING_SERVICE_SID: ${{ secrets.TWILIO_MESSAGING_SERVICE_SID }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_FROM_EMAIL: ${{ secrets.SENDGRID_FROM_EMAIL }}
        with:
          host: ${{ steps.get-ip.outputs.ec2_ip }}
          username: ubuntu
          key: ${{ secrets.SECRET_KEY }}
          envs: COMMIT_SHA,S3_BUCKET,SKIP_BUILD,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION,ANTHROPIC_API_KEY,APP_URL,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,TWILIO_ACCOUNT_SID,TWILIO_AUTH_TOKEN,TWILIO_PHONE_NUMBER,TWILIO_MESSAGING_SERVICE_SID,SENDGRID_API_KEY,SENDGRID_FROM_EMAIL
          script_stop: true
          command_timeout: 45m
          script: |
            set -e
            echo "=== Starting SSH deployment ==="

            WORKDIR=/tmp/autoapply-deployment
            mkdir -p $WORKDIR
            cd $WORKDIR

            echo "=== Downloading deployment package from S3 ==="
            aws s3 cp s3://$S3_BUCKET/deployments/autoapply-$COMMIT_SHA.tar.gz . || {
              echo "‚ùå Failed to download from S3"
              exit 1
            }

            echo "=== Extracting package ==="
            tar -xzf autoapply-$COMMIT_SHA.tar.gz || {
              echo "‚ùå Failed to extract package"
              exit 1
            }

            if [ "$SKIP_BUILD" != "true" ]; then
              echo "=== Building Docker image ==="
              echo "Using BuildKit with caching for faster builds..."

              # Enable BuildKit for better caching and performance
              export DOCKER_BUILDKIT=1

              # Build with progress output and build cache
              docker build \
                --progress=plain \
                --build-arg BUILDKIT_INLINE_CACHE=1 \
                -t autoapply:$COMMIT_SHA \
                -t autoapply:latest \
                . 2>&1 | tee /tmp/docker-build.log || {
                echo "‚ùå Docker build failed"
                echo "Last 50 lines of build log:"
                tail -50 /tmp/docker-build.log
                exit 1
              }
              echo "‚úÖ Docker build successful"
              docker images | grep autoapply
            else
              echo "‚è≠Ô∏è  Skipping Docker build (using existing image)"
            fi

            echo "=== Stopping old container ==="
            docker stop autoapply 2>/dev/null || echo "No running container"
            docker rm autoapply 2>/dev/null || echo "No container to remove"

            echo "=== Starting new container ==="
            docker run -d \
              --name autoapply \
              --restart unless-stopped \
              -p 80:3000 \
              -e NODE_ENV=production \
              -e AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
              -e AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
              -e AWS_REGION="$AWS_REGION" \
              -e S3_BUCKET_NAME="$S3_BUCKET" \
              -e ANTHROPIC_API_KEY="$ANTHROPIC_API_KEY" \
              -e APP_URL="$APP_URL" \
              -e JWT_ACCESS_SECRET="$(openssl rand -hex 32)" \
              -e JWT_REFRESH_SECRET="$(openssl rand -hex 32)" \
              -e ENCRYPTION_KEY="$(openssl rand -hex 32)" \
              -e GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
              -e GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
              -e GOOGLE_REDIRECT_URI="$APP_URL/api/auth/oauth/google/callback" \
              -e TWILIO_ACCOUNT_SID="$TWILIO_ACCOUNT_SID" \
              -e TWILIO_AUTH_TOKEN="$TWILIO_AUTH_TOKEN" \
              -e TWILIO_PHONE_NUMBER="$TWILIO_PHONE_NUMBER" \
              -e TWILIO_MESSAGING_SERVICE_SID="$TWILIO_MESSAGING_SERVICE_SID" \
              -e SENDGRID_API_KEY="$SENDGRID_API_KEY" \
              -e SENDGRID_FROM_EMAIL="$SENDGRID_FROM_EMAIL" \
              autoapply:latest || {
                echo "‚ùå Failed to start container"
                exit 1
              }

            echo "‚úÖ Container started"
            docker ps | grep autoapply

            echo "=== Waiting for app to initialize ==="
            sleep 10

            echo "=== Container logs (last 50 lines) ==="
            docker logs autoapply --tail 50

            echo "=== Testing health endpoint ==="
            for i in {1..10}; do
              if curl -f http://localhost:3000/api/health 2>/dev/null; then
                echo "‚úÖ Health check passed"
                break
              fi
              echo "Attempt $i/10 failed, waiting..."
              sleep 3
            done

            echo "=== Cleaning up ==="
            docker image prune -f
            cd /tmp
            rm -rf $WORKDIR

            echo "=== Deployment complete ==="

      - name: External health check
        run: |
          echo "Waiting for application to fully start..."
          sleep 20

          MAX_ATTEMPTS=10
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "External health check attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS..."
            if curl -f http://${{ steps.get-ip.outputs.ec2_ip }}/api/health 2>/dev/null; then
              echo "‚úÖ External health check passed!"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep 5
          done

          echo "‚ö†Ô∏è External health check failed, but deployment may still be successful"
          echo "Check manually: http://${{ steps.get-ip.outputs.ec2_ip }}/api/health"

      - name: Deployment summary
        if: success()
        run: |
          echo "üéâ Deployment complete!"
          echo ""
          echo "üìä Details:"
          echo "  URL: ${{ secrets.NEXTAUTH_URL }}"
          echo "  IP: ${{ steps.get-ip.outputs.ec2_ip }}"
          echo "  Health: http://${{ steps.get-ip.outputs.ec2_ip }}/api/health"
          echo "  Commit: ${{ github.sha }}"
          echo ""
          echo "üîç Next steps:"
          echo "  1. Visit the health endpoint to verify"
          echo "  2. Check application logs if needed"
          echo "  3. Test main functionality"
